> CREATE TS DATABASE db_pipec;
CREATE TS DATABASE
> CREATE TABLE db_pipec.t_point (
    k_timestamp timestamp NOT NULL,
    measure_value double
) ATTRIBUTES (
    point_sn varchar(64) NOT NULL,
    sub_com_sn varchar(32),
    work_area_sn varchar(16),
    station_sn varchar(16),
    pipeline_sn varchar(16) not null,
    measure_type smallint,
    measure_location varchar(64))
  PRIMARY TAGS(point_sn)
  ACTIVETIME 3h;
CREATE TABLE
> insert into db_pipec.t_point values('2024-08-27 11:00:00',10.5,'a0','b0','c0','d0','e0',1,'f0');
INSERT 1
> insert into db_pipec.t_point values('2024-08-27 12:00:00',11.5,'a1','b1','c1','d1','e1',1,'f1');
INSERT 1
> insert into db_pipec.t_point values('2024-08-27 13:00:00',11.8,'a1','b1','c1','d1','e1',1,'f1');
INSERT 1
> insert into db_pipec.t_point values('2024-08-27 10:00:00',12.5,'a2','b2','c2','d2','e2',2,'f2');
INSERT 1
> insert into db_pipec.t_point values('2024-08-26 10:00:00',13.5,'a3','b3','c3','d3','e3',2,'f3');
INSERT 1
> insert into db_pipec.t_point values('2024-08-28 10:00:00',14.5,'a4','b4','c4','d4','e4',3,'f4');
INSERT 1
> insert into db_pipec.t_point values('2024-08-29 10:00:00',15.5,'a5','b5','c5','d5','e5',3,'f5');
INSERT 1
> insert into db_pipec.t_point values('2024-08-28 11:00:00',10.5,'a6','b6','c6','d6','e6',4,'f6');
INSERT 1
> insert into db_pipec.t_point values('2024-08-28 12:00:00',11.5,'a7','b7','c7','d7','e7',4,'f7');
INSERT 1
> CREATE STATISTICS _stats_ FROM db_pipec.t_point;
CREATE STATISTICS
> CREATE DATABASE pipec_r;
CREATE DATABASE
> CREATE TABLE pipec_r.station_info (
    station_sn varchar(16) PRIMARY KEY,
    station_name varchar(80),
    work_area_sn varchar(16),
    workarea_name varchar(80),
    sub_company_sn varchar(32),
    sub_company_name varchar(50));
CREATE TABLE
> CREATE INDEX station_sn_index ON pipec_r.station_info(work_area_sn);
CREATE INDEX
> CREATE INDEX station_name_index ON pipec_r.station_info(workarea_name);
CREATE INDEX
> insert into pipec_r.station_info values('d0','dd','c0','aa','b','bb');
INSERT 1
> insert into pipec_r.station_info values('d1','dd','c1','aa','b','bb');
INSERT 1
> insert into pipec_r.station_info values('d2','dd','c2','aa','b','bb');
INSERT 1
> insert into pipec_r.station_info values('d3','dd','c3','aa','b','bb');
INSERT 1
> insert into pipec_r.station_info values('d4','dd','c4','aa','b','bb');
INSERT 1
> insert into pipec_r.station_info values('d5','dd','c5','aa','b','bb');
INSERT 1
> CREATE STATISTICS _stats_ FROM pipec_r.station_info;
CREATE STATISTICS
> CREATE TABLE pipec_r.pipeline_info (
    pipeline_sn varchar(16) PRIMARY KEY,
    pipeline_name varchar(60),
    pipe_start varchar(80),
    pipe_end varchar(80),
    pipe_properties varchar(30));
CREATE TABLE
> CREATE INDEX pipeline_sn_index ON pipec_r.pipeline_info (pipeline_sn);
CREATE INDEX
> CREATE INDEX pipeline_name_index ON pipec_r.pipeline_info (pipeline_name);
CREATE INDEX
> insert into pipec_r.pipeline_info values('e0','pipeline_0','a','aa','b');
INSERT 1
> insert into pipec_r.pipeline_info values('e1','pipeline_1','a','aa','b');
INSERT 1
> insert into pipec_r.pipeline_info values('e2','pipeline_2','a','aa','b');
INSERT 1
> insert into pipec_r.pipeline_info values('e3','pipeline_3','a','aa','b');
INSERT 1
> insert into pipec_r.pipeline_info values('e4','pipeline_4','a','aa','b');
INSERT 1
> insert into pipec_r.pipeline_info values('e5','pipeline_5','a','aa','b');
INSERT 1
> CREATE STATISTICS _stats_ FROM pipec_r.pipeline_info;
CREATE STATISTICS
> CREATE TABLE pipec_r.point_info (
    point_sn varchar(64) PRIMARY KEY,
    signal_code varchar(120),
    signal_description varchar(200),
    signal_type varchar(50),
    station_sn varchar(16),
    pipeline_sn varchar(16));
CREATE TABLE
> insert into pipec_r.point_info values('a0','ee','a','aa','d0','e0');
INSERT 1
> insert into pipec_r.point_info values('a1','ee','a','aa','d1','e1');
INSERT 1
> insert into pipec_r.point_info values('a2','ee','a','aa','d2','e2');
INSERT 1
> insert into pipec_r.point_info values('a3','ee','a','aa','d3','e3');
INSERT 1
> insert into pipec_r.point_info values('a4','ee','a','aa','d4','e4');
INSERT 1
> insert into pipec_r.point_info values('a5','ee','a','aa','d5','e5');
INSERT 1
> CREATE STATISTICS _stats_ FROM pipec_r.point_info;
CREATE STATISTICS
> CREATE TABLE pipec_r.workarea_info (
  work_area_sn varchar(16) PRIMARY KEY,
  work_area_name varchar(80),
  work_area_location varchar(64), 
  work_area_description varchar(128));
CREATE TABLE
> CREATE INDEX workarea_name_index ON pipec_r.workarea_info(work_area_name);
CREATE INDEX
> insert into pipec_r.workarea_info values('c0','work_area_0','l0','aa');
INSERT 1
> insert into pipec_r.workarea_info values('c1','work_area_1','l1','aa');
INSERT 1
> insert into pipec_r.workarea_info values('c2','work_area_2','l2','aa');
INSERT 1
> insert into pipec_r.workarea_info values('c3','work_area_3','l3','aa');
INSERT 1
> insert into pipec_r.workarea_info values('c4','work_area_4','l4','aa');
INSERT 1
> insert into pipec_r.workarea_info values('c5','work_area_5','l5','aa');
INSERT 1
> CREATE STATISTICS _stats_ FROM pipec_r.workarea_info;
CREATE STATISTICS
> create database test_rel;
CREATE DATABASE
> create table test_rel.rel_t1(c1 UUID NOT NULL DEFAULT gen_random_uuid(), 
                             c2 BIT, c3 INET, c4 JSONB, c5 INT ARRAY, 
                             c6 INT, c7 FLOAT, c8 TIMESTAMP);
CREATE TABLE
> insert into test_rel.rel_t1(c2, c3, c4, c5, c6, c7, c8) values 
   (B'1', '192.168.0.1', '{"type": "account creation", "username": "harvestboy93"}', 
    ARRAY[10,20,30], 5, 75.1234567, TIMESTAMP '2024-01-04 14:32:01');
INSERT 1
> insert into test_rel.rel_t1(c2, c3, c4, c5, c6, c7, c8) values 
   (B'0', '192.168.0.2', '{"type": "account creation", "username": "hungrygame"}', 
    ARRAY[15,25,35], 4, 65.31, TIMESTAMP '2024-01-04 14:33:01');
INSERT 1
> CREATE STATISTICS _stats_ FROM pipec_r.rel_t1;
ERROR: relation "pipec_r.rel_t1" does not exist
SQLSTATE: 42P01
> set enable_multimodel=true;
SET
> explain SELECT si.station_name,
       COUNT(t.measure_value),
       AVG(t.measure_value)
FROM pipec_r.station_info si,
     pipec_r.workarea_info wi,
     db_pipec.t_point t
GROUP BY si.station_name
HAVING COUNT(t.measure_value) > 0
ORDER BY si.station_name;
                tree               |         field         |                description
-----------------------------------+-----------------------+---------------------------------------------
                                   | distributed           | true
                                   | vectorized            | false
  sort                             |                       |
   │                               | order                 | +station_name
   └── filter                      |                       |
        │                          | filter                | count > 0
        └── group                  |                       |
             │                     | aggregate 0           | station_name
             │                     | aggregate 1           | count(measure_value)
             │                     | aggregate 2           | avg(measure_value)
             │                     | group by              | station_name
             └── cross-join        |                       |
                  │                | type                  | cross
                  ├── synchronizer |                       |
                  │    └── ts scan |                       |
                  │                | ts-table              | t_point
                  │                | access mode           | metaTable
                  └── cross-join   |                       |
                       │           | type                  | cross
                       ├── scan    |                       |
                       │           | table                 | station_info@primary
                       │           | spans                 | FULL SCAN
                       └── scan    |                       |
                                   | table                 | workarea_info@workarea_name_index
                                   | spans                 | FULL SCAN
                                   |                       |
  warning messages                 | multi-model fall back | cross join is not supported in multi-model
(27 rows)
> explain SELECT si.station_name,
       STDDEV(t.measure_value)
FROM pipec_r.station_info si,
     pipec_r.workarea_info wi,
     db_pipec.t_point t
WHERE wi.work_area_name = 'work_area_1'
  AND wi.work_area_sn = si.work_area_sn
  AND si.station_sn = t.station_sn
  AND t.measure_type = 5
  AND t.measure_value > 80
GROUP BY si.station_name
ORDER BY si.station_name;
                  tree                  |         field         |                  description
----------------------------------------+-----------------------+-------------------------------------------------
                                        | distributed           | true
                                        | vectorized            | false
  group                                 |                       |
   │                                    | aggregate 0           | station_name
   │                                    | aggregate 1           | stddev(measure_value)
   │                                    | group by              | station_name
   │                                    | ordered               | +station_name
   └── render                           |                       |
        │                               | measure_value         | measure_value
        │                               | station_name          | station_name
        └── sort                        |                       |
             │                          | order                 | +station_name
             └── hash-join              |                       |
                  │                     | type                  | inner
                  │                     | equality              | (work_area_sn) = (work_area_sn)
                  │                     | left cols are key     |
                  ├── scan              |                       |
                  │                     | table                 | workarea_info@workarea_name_index
                  │                     | spans                 | /"work_area_1"-/"work_area_1"/PrefixEnd
                  └── lookup-join       |                       |
                       │                | table                 | station_info@primary
                       │                | type                  | inner
                       │                | equality              | (station_sn) = (station_sn)
                       │                | equality cols are key |
                       │                | parallel              |
                       └── synchronizer |                       |
                            └── ts scan |                       |
                                        | ts-table              | t_point
                                        | access mode           | tableTableMeta
                                        | filter                | measure_value > 80.0
                                        | tag filter[0]         | measure_type = 5
                                        |                       |
  warning messages                      | multi-model fall back | unsupported aggregation function or expression
(33 rows)
> explain SELECT si.station_name,
       CORR(t.measure_type, t.measure_value)
FROM pipec_r.station_info si,
     pipec_r.workarea_info wi,
     db_pipec.t_point t
WHERE wi.work_area_name = 'work_area_1'
  AND wi.work_area_sn = si.work_area_sn
  AND si.station_sn = t.station_sn
  AND t.measure_type = 5
  AND t.measure_value > 80
GROUP BY si.station_name
ORDER BY si.station_name;
                  tree                  |         field         |                  description
----------------------------------------+-----------------------+-------------------------------------------------
                                        | distributed           | true
                                        | vectorized            | false
  group                                 |                       |
   │                                    | aggregate 0           | station_name
   │                                    | aggregate 1           | corr(measure_type, measure_value)
   │                                    | group by              | station_name
   │                                    | ordered               | +station_name
   └── render                           |                       |
        │                               | measure_value         | measure_value
        │                               | measure_type          | measure_type
        │                               | station_name          | station_name
        └── sort                        |                       |
             │                          | order                 | +station_name
             └── hash-join              |                       |
                  │                     | type                  | inner
                  │                     | equality              | (work_area_sn) = (work_area_sn)
                  │                     | left cols are key     |
                  ├── scan              |                       |
                  │                     | table                 | workarea_info@workarea_name_index
                  │                     | spans                 | /"work_area_1"-/"work_area_1"/PrefixEnd
                  └── lookup-join       |                       |
                       │                | table                 | station_info@primary
                       │                | type                  | inner
                       │                | equality              | (station_sn) = (station_sn)
                       │                | equality cols are key |
                       │                | parallel              |
                       └── synchronizer |                       |
                            └── ts scan |                       |
                                        | ts-table              | t_point
                                        | access mode           | tableTableMeta
                                        | filter                | measure_value > 80.0
                                        | tag filter[0]         | measure_type = 5
                                        |                       |
  warning messages                      | multi-model fall back | unsupported aggregation function or expression
(34 rows)
> explain SELECT si.station_name, string_agg(t.pipeline_sn, t.work_area_sn)
FROM pipec_r.station_info si,
     pipec_r.workarea_info wi,
     db_pipec.t_point t
WHERE wi.work_area_name = 'work_area_1'
  AND wi.work_area_sn = si.work_area_sn
  AND si.station_sn = t.station_sn
  AND t.measure_type = 5
  AND t.measure_value > 80
GROUP BY si.station_name
ORDER BY si.station_name;
                  tree                  |         field         |                  description
----------------------------------------+-----------------------+-------------------------------------------------
                                        | distributed           | true
                                        | vectorized            | false
  group                                 |                       |
   │                                    | aggregate 0           | station_name
   │                                    | aggregate 1           | string_agg(pipeline_sn, work_area_sn)
   │                                    | group by              | station_name
   │                                    | ordered               | +station_name
   └── render                           |                       |
        │                               | work_area_sn          | work_area_sn
        │                               | pipeline_sn           | pipeline_sn
        │                               | station_name          | station_name
        └── sort                        |                       |
             │                          | order                 | +station_name
             └── hash-join              |                       |
                  │                     | type                  | inner
                  │                     | equality              | (work_area_sn) = (work_area_sn)
                  │                     | left cols are key     |
                  ├── scan              |                       |
                  │                     | table                 | workarea_info@workarea_name_index
                  │                     | spans                 | /"work_area_1"-/"work_area_1"/PrefixEnd
                  └── lookup-join       |                       |
                       │                | table                 | station_info@primary
                       │                | type                  | inner
                       │                | equality              | (station_sn) = (station_sn)
                       │                | equality cols are key |
                       │                | parallel              |
                       └── synchronizer |                       |
                            └── ts scan |                       |
                                        | ts-table              | t_point
                                        | access mode           | tableTableMeta
                                        | filter                | measure_value > 80.0
                                        | tag filter[0]         | measure_type = 5
                                        |                       |
  warning messages                      | multi-model fall back | unsupported aggregation function or expression
(34 rows)
> explain SELECT wi.work_area_name,
       t.measure_type,
       COUNT(DISTINCT t.point_sn) AS measure_point_count
FROM pipec_r.pipeline_info li,          -- 26
     pipec_r.station_info si,           -- 436
     pipec_r.workarea_info wi,          -- 41
     db_pipec.t_point t                 -- 45M
WHERE cast(li.pipeline_sn as float) = t.measure_type
  AND si.work_area_sn = wi.work_area_sn
  AND si.work_area_sn = t.work_area_sn
  AND li.pipeline_name = 'pipeline_1'
GROUP BY
    wi.work_area_name, t.measure_type
ORDER BY
    wi.work_area_name, t.measure_type;
                      tree                     |         field         |                         description
-----------------------------------------------+-----------------------+---------------------------------------------------------------
                                               | distributed           | true
                                               | vectorized            | false
  render                                       |                       |
   │                                           | work_area_name        | work_area_name
   │                                           | measure_type          | measure_type
   │                                           | measure_point_count   | count
   └── group                                   |                       |
        │                                      | aggregate 0           | measure_type
        │                                      | aggregate 1           | work_area_name
        │                                      | aggregate 2           | count(DISTINCT point_sn)
        │                                      | group by              | measure_type, work_area_name
        │                                      | ordered               | +work_area_name,+measure_type
        └── render                             |                       |
             │                                 | point_sn              | point_sn
             │                                 | measure_type          | measure_type
             │                                 | work_area_name        | work_area_name
             └── sort                          |                       |
                  │                            | order                 | +work_area_name,+measure_type
                  └── hash-join                |                       |
                       │                       | type                  | inner
                       │                       | equality              | (work_area_sn) = (work_area_sn)
                       │                       | pred                  | measure_type = column25
                       ├── synchronizer        |                       |
                       │    └── ts scan        |                       |
                       │                       | ts-table              | t_point
                       │                       | access mode           | hashTagScan
                       └── render              |                       |
                            └── cross-join     |                       |
                                 │             | type                  | cross
                                 ├── hash-join |                       |
                                 │    │        | type                  | inner
                                 │    │        | equality              | (work_area_sn) = (work_area_sn)
                                 │    │        | right cols are key    |
                                 │    ├── scan |                       |
                                 │    │        | table                 | station_info@station_sn_index
                                 │    │        | spans                 | FULL SCAN
                                 │    └── scan |                       |
                                 │             | table                 | workarea_info@workarea_name_index
                                 │             | spans                 | FULL SCAN
                                 └── scan      |                       |
                                               | table                 | pipeline_info@pipeline_name_index
                                               | spans                 | /"pipeline_1"-/"pipeline_1"/PrefixEnd
                                               |                       |
  warning messages                             | multi-model fall back | mismatch in left join columns' positions with relationalInfo
(44 rows)
> explain SELECT li.pipeline_name,
       t.measure_type,
       time_bucket(t.k_timestamp, '10s') as timebucket,
       AVG(t.measure_value) AS avg_value,
       MAX(t.measure_value) AS max_value,
       MIN(t.measure_value) AS min_value,
       COUNT(t.measure_value) AS number_of_values
FROM pipec_r.pipeline_info li,
     test_rel.rel_t1 t1,
     db_pipec.t_point t                -- 45M
WHERE t1.c7 = t.measure_value   -- 26, 21
GROUP BY
    li.pipeline_name,
    t.measure_type,
    timebucket
ORDER BY
    li.pipeline_name,
    t.measure_type,
    timebucket;
                     tree                    |         field         |               description
---------------------------------------------+-----------------------+-------------------------------------------
                                             | distributed           | true
                                             | vectorized            | false
  render                                     |                       |
   │                                         | pipeline_name         | pipeline_name
   │                                         | measure_type          | measure_type
   │                                         | timebucket            | timebucket
   │                                         | avg_value             | avg
   │                                         | max_value             | max
   │                                         | min_value             | min
   │                                         | number_of_values      | count
   └── sort                                  |                       |
        │                                    | order                 | +pipeline_name,+measure_type,+timebucket
        └── group                            |                       |
             │                               | aggregate 0           | measure_type
             │                               | aggregate 1           | pipeline_name
             │                               | aggregate 2           | timebucket
             │                               | aggregate 3           | avg(measure_value)
             │                               | aggregate 4           | max(measure_value)
             │                               | aggregate 5           | min(measure_value)
             │                               | aggregate 6           | count(measure_value)
             │                               | group by              | measure_type, pipeline_name, timebucket
             └── render                      |                       |
                  │                          | timebucket            | time_bucket(k_timestamp, '10s')
                  │                          | measure_value         | measure_value
                  │                          | measure_type          | measure_type
                  │                          | pipeline_name         | pipeline_name
                  └── hash-join              |                       |
                       │                     | type                  | inner
                       │                     | equality              | (c7) = (measure_value)
                       ├── scan              |                       |
                       │                     | table                 | rel_t1@primary
                       │                     | spans                 | FULL SCAN
                       └── cross-join        |                       |
                            │                | type                  | cross
                            ├── synchronizer |                       |
                            │    └── ts scan |                       |
                            │                | ts-table              | t_point
                            │                | access mode           | tableTableMeta
                            └── scan         |                       |
                                             | table                 | pipeline_info@pipeline_name_index
                                             | spans                 | FULL SCAN
                                             |                       |
  warning messages                           | multi-model fall back | join between time-series tables
(43 rows)
> explain SELECT si.station_name,
       COUNT(DISTINCT point_sn) AS abnormal_point_count
FROM pipec_r.pipeline_info li,      
     pipec_r.station_info si,       
     db_pipec.t_point t             
WHERE li.pipeline_sn = t.pipeline_sn            
    AND t.station_sn = si.station_sn             
    AND li.pipeline_name = 'pipeline_1'         
    AND t.measure_type = 4                      
    AND t.k_timestamp >= '2023-08-01 00:00:00'
    AND t.k_timestamp <= '2024-08-01 01:00:00'   
    AND t.measure_value < 0.5 * (
        SELECT AVG(t1.measure_value) 
        FROM db_pipec.t_point t1               
        WHERE t1.pipeline_sn = li.pipeline_sn    
          AND t1.measure_type = 4)              
GROUP BY
    si.station_name
ORDER BY
    abnormal_point_count DESC;
                       tree                       |         field         |                                          description
--------------------------------------------------+-----------------------+------------------------------------------------------------------------------------------------
                                                  | distributed           | true
                                                  | vectorized            | false
  sort                                            |                       |
   │                                              | order                 | -abnormal_point_count
   └── group                                      |                       |
        │                                         | aggregate 0           | any_not_null
        │                                         | aggregate 1           | count(DISTINCT point_sn)
        │                                         | group by              | any_not_null
        └── render                                |                       |
             │                                    | point_sn              | point_sn
             │                                    | any_not_null          | any_not_null
             └── hash-join                        |                       |
                  │                               | type                  | inner
                  │                               | equality              | (pipeline_sn, station_sn) = (pipeline_sn, station_sn)
                  │                               | left cols are key     |
                  │                               | pred                  | measure_value < (avg * 0.5)
                  ├── group                       |                       |
                  │    │                          | aggregate 0           | pipeline_sn
                  │    │                          | aggregate 1           | station_sn
                  │    │                          | aggregate 2           | avg(measure_value)
                  │    │                          | aggregate 3           | any_not_null(station_name)
                  │    │                          | group by              | pipeline_sn, station_sn
                  │    └── render                 |                       |
                  │         │                     | pipeline_sn           | pipeline_sn
                  │         │                     | station_sn            | station_sn
                  │         │                     | station_name          | station_name
                  │         │                     | measure_value         | measure_value
                  │         └── hash-join         |                       |
                  │              │                | type                  | left outer
                  │              │                | equality              | (pipeline_sn) = (pipeline_sn)
                  │              ├── cross-join   |                       |
                  │              │    │           | type                  | cross
                  │              │    ├── scan    |                       |
                  │              │    │           | table                 | station_info@primary
                  │              │    │           | spans                 | FULL SCAN
                  │              │    └── scan    |                       |
                  │              │                | table                 | pipeline_info@pipeline_name_index
                  │              │                | spans                 | /"pipeline_1"-/"pipeline_1"/PrefixEnd
                  │              └── synchronizer |                       |
                  │                   └── ts scan |                       |
                  │                               | ts-table              | t_point
                  │                               | access mode           | tableTableMeta
                  │                               | tag filter[0]         | measure_type = 4
                  └── synchronizer                |                       |
                       └── ts scan                |                       |
                                                  | ts-table              | t_point
                                                  | access mode           | tableTableMeta
                                                  | filter                | (k_timestamp <= '2024-08-01 01:00:00+00:00') AND (k_timestamp >= '2023-08-01 00:00:00+00:00')
                                                  | tag filter[0]         | measure_type = 4
                                                  |                       |
  warning messages                                | multi-model fall back | join between time-series tables
(51 rows)
> explain SELECT si.station_name
FROM pipec_r.station_info si,              
     pipec_r.workarea_info wi,             
     db_pipec.t_point t                   
WHERE wi.work_area_name = 'work_area_1'    
  AND wi.work_area_sn = si.work_area_sn        
  AND t.measure_type = cast(si.station_sn as int)                  
  AND t.measure_value > 80                
GROUP BY si.station_name
ORDER BY si.station_name;
                 tree                |         field         |               description
-------------------------------------+-----------------------+-------------------------------------------
                                     | distributed           | true
                                     | vectorized            | false
  sort                               |                       |
   │                                 | order                 | +station_name
   └── distinct                      |                       |
        │                            | distinct on           | station_name
        └── render                   |                       |
             │                       | station_name          | station_name
             └── hash-join           |                       |
                  │                  | type                  | inner
                  │                  | equality              | (measure_type) = (column20)
                  ├── synchronizer   |                       |
                  │    └── ts scan   |                       |
                  │                  | ts-table              | t_point
                  │                  | access mode           | tableTableMeta
                  │                  | filter                | measure_value > 80.0
                  └── render         |                       |
                       └── hash-join |                       |
                            │        | type                  | inner
                            │        | equality              | (work_area_sn) = (work_area_sn)
                            │        | right cols are key    |
                            ├── scan |                       |
                            │        | table                 | station_info@primary
                            │        | spans                 | FULL SCAN
                            └── scan |                       |
                                     | table                 | workarea_info@workarea_name_index
                                     | spans                 | /"work_area_1"-/"work_area_1"/PrefixEnd
                                     |                       |
  warning messages                   | multi-model fall back | mismatch in join columns' type or length
(29 rows)
> explain SELECT
    LOWER(wi.work_area_name) AS work_area_name,  
    CONCAT(si.station_name, ' Station') AS station_name,  
    t.measure_type + 1,
    time_bucket(t.k_timestamp, '10s') as timebucket,
    (EXTRACT(EPOCH FROM t.k_timestamp) / 600)::int * 600 AS timebucket_epoch,
    (CASE 
        WHEN t.measure_value > 100 THEN 'High'
        ELSE 'Low'
    END) AS value_range,
    AVG(t.measure_value) AS avg_value,
    MAX(t.measure_value) AS max_value,
    MIN(t.measure_value) AS min_value,
    COUNT(t.measure_value) AS number_of_values
FROM
    pipec_r.station_info si,
    pipec_r.workarea_info wi,
    pipec_r.pipeline_info li,
    pipec_r.point_info pi,
    db_pipec.t_point t
WHERE
    li.pipeline_sn = pi.pipeline_sn
    AND pi.station_sn = si.station_sn
    AND si.work_area_sn = wi.work_area_sn
    AND t.point_sn = pi.point_sn
    AND li.pipeline_name = 'pipeline_1'
    AND wi.work_area_name IN ('work_area_1', 'work_area_2', 'work_area_3')
    AND t.k_timestamp >= '2023-08-01 01:00:00'
GROUP BY
    LOWER(wi.work_area_name), 
    CONCAT(si.station_name, ' Station'), 
    t.measure_type + 1,
    time_bucket(t.k_timestamp, '10s'),
    (EXTRACT(EPOCH FROM t.k_timestamp) / 600)::int * 600, 
    (CASE 
        WHEN t.measure_value > 100 THEN 'High'
        ELSE 'Low'
    END);
                 tree                |                           field                            |                                                                                                         description
-------------------------------------+------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                     | distributed                                                | true
                                     | vectorized                                                 | false
  group                              |                                                            |
   │                                 | aggregate 0                                                | lower(work_area_name)
   │                                 | aggregate 1                                                | concat(station_name, ' Station')
   │                                 | aggregate 2                                                | measure_type + 1
   │                                 | aggregate 3                                                | time_bucket(k_timestamp, '10s')
   │                                 | aggregate 4                                                | (extract('epoch', k_timestamp) / 600.0)::INT4 * 600
   │                                 | aggregate 5                                                | CASE WHEN measure_value > 100.0 THEN 'High' ELSE 'Low' END
   │                                 | aggregate 6                                                | avg(measure_value)
   │                                 | aggregate 7                                                | max(measure_value)
   │                                 | aggregate 8                                                | min(measure_value)
   │                                 | aggregate 9                                                | count(measure_value)
   │                                 | group by                                                   | lower(work_area_name), concat(station_name, ' Station'), measure_type + 1, time_bucket(k_timestamp, '10s'), (extract('epoch', k_timestamp) / 600.0)::INT4 * 600, CASE WHEN measure_value > 100.0 THEN 'High' ELSE 'Low' END
   └── render                        |                                                            |
        │                            | lower(work_area_name)                                      | lower(work_area_name)
        │                            | concat(station_name, ' Station')                           | concat(station_name, ' Station')
        │                            | measure_type + 1                                           | measure_type + 1
        │                            | time_bucket(k_timestamp, '10s')                            | time_bucket(k_timestamp, '10s')
        │                            | (extract('epoch', k_timestamp) / 600.0)::INT4 * 600        | (extract('epoch', k_timestamp) / 600.0)::INT4 * 600
        │                            | CASE WHEN measure_value > 100.0 THEN 'High' ELSE 'Low' END | CASE WHEN measure_value > 100.0 THEN 'High' ELSE 'Low' END
        │                            | measure_value                                              | measure_value
        └── hash-join                |                                                            |
             │                       | type                                                       | inner
             │                       | equality                                                   | (point_sn) = (point_sn)
             │                       | right cols are key                                         |
             ├── synchronizer        |                                                            |
             │    └── ts scan        |                                                            |
             │                       | ts-table                                                   | t_point
             │                       | access mode                                                | tableTableMeta
             │                       | spans:fromTime                                             | 2023-08-01 01:00:00 +0000 UTC
             │                       | spans:toTime                                               | 2970-01-01 00:00:00 +0000 UTC
             └── hash-join           |                                                            |
                  │                  | type                                                       | inner
                  │                  | equality                                                   | (work_area_sn) = (work_area_sn)
                  │                  | left cols are key                                          |
                  ├── scan           |                                                            |
                  │                  | table                                                      | workarea_info@workarea_name_index
                  │                  | spans                                                      | /"work_area_1"-/"work_area_1"/PrefixEnd /"work_area_2"-/"work_area_2"/PrefixEnd /"work_area_3"-/"work_area_3"/PrefixEnd
                  └── lookup-join    |                                                            |
                       │             | table                                                      | station_info@primary
                       │             | type                                                       | inner
                       │             | equality                                                   | (station_sn) = (station_sn)
                       │             | equality cols are key                                      |
                       │             | parallel                                                   |
                       └── hash-join |                                                            |
                            │        | type                                                       | inner
                            │        | equality                                                   | (pipeline_sn) = (pipeline_sn)
                            │        | right cols are key                                         |
                            ├── scan |                                                            |
                            │        | table                                                      | point_info@primary
                            │        | spans                                                      | FULL SCAN
                            └── scan |                                                            |
                                     | table                                                      | pipeline_info@pipeline_name_index
                                     | spans                                                      | /"pipeline_1"-/"pipeline_1"/PrefixEnd
                                     |                                                            |
  warning messages                   | multi-model fall back                                      | unsupported aggregation function or expression
(57 rows)
> set enable_multimodel=true;
SET
> SELECT si.station_name,
       COUNT(DISTINCT point_sn) AS abnormal_point_count
FROM pipec_r.pipeline_info li,
     pipec_r.station_info si,
     db_pipec.t_point t
WHERE li.pipeline_sn = t.pipeline_sn
    AND t.station_sn = si.station_sn
    AND li.pipeline_name = 'pipeline_1'
    AND t.k_timestamp >= '2023-08-01 00:00:00'
    AND t.k_timestamp <= '2025-08-01 01:00:00'
    AND t.measure_value < 2 * (
        SELECT AVG(t1.measure_value)
        FROM db_pipec.t_point t1
        WHERE t1.pipeline_sn = li.pipeline_sn)
GROUP BY
    si.station_name
ORDER BY
    abnormal_point_count DESC;
  station_name | abnormal_point_count
---------------+-----------------------
  dd           |                    1
(1 row)
> DROP TABLE test_rel.rel_t1;
DROP TABLE
> DROP TABLE pipec_r.workarea_info;
DROP TABLE
> DROP TABLE pipec_r.point_info;
DROP TABLE
> DROP TABLE pipec_r.pipeline_info;
DROP TABLE
> DROP TABLE pipec_r.station_info;
DROP TABLE
> DROP TABLE db_pipec.t_point;
DROP TABLE
> DROP DATABASE pipec_r;
DROP DATABASE
> DROP DATABASE db_pipec;
DROP DATABASE
> DROP DATABASE test_rel;
DROP DATABASE
> set enable_multimodel=false;
SET
